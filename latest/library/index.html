<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · LibHealpix.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LibHealpix.jl logo"/></a><h1>LibHealpix.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../cookbook/">Cookbook</a></li></ul></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Pixel-Functions-1">Pixel Functions</a></li><li><a class="toctext" href="#Healpix-Maps-1">Healpix Maps</a></li><li><a class="toctext" href="#Spherical-Harmonic-Coefficients-1">Spherical Harmonic Coefficients</a></li><li><a class="toctext" href="#Spherical-Harmonic-Transforms-1">Spherical Harmonic Transforms</a></li><li><a class="toctext" href="#Visualization-1">Visualization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/docs/src/library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><h2><a class="nav-anchor" id="Pixel-Functions-1" href="#Pixel-Functions-1">Pixel Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.nside2npix" href="#LibHealpix.nside2npix"><code>LibHealpix.nside2npix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nside2npix(nside)</code></pre><p>Compute the number of pixels in a Healpix map with the given value of <code>nside</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; nside2npix(4)
192

julia&gt; nside2npix(256)
786432</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.npix2nside"><code>npix2nside</code></a>, <a href="#LibHealpix.nside2nring"><code>nside2nring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L16-L36">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.npix2nside" href="#LibHealpix.npix2nside"><code>LibHealpix.npix2nside</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">npix2nside(npix)</code></pre><p>Compute the value of the <code>nside</code> parameter for a Healpix map with the given number of pixels.</p><p><strong>Arguments:</strong></p><ul><li><p><code>npix</code> - the number of pixels in the map</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; npix2nside(192)
4

julia&gt; npix2nside(786432)
256</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.nside2npix"><code>nside2npix</code></a>, <a href="#LibHealpix.nside2nring"><code>nside2nring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L39-L59">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.nside2nring" href="#LibHealpix.nside2nring"><code>LibHealpix.nside2nring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nside2nring(nside)</code></pre><p>Compute the number of equal latitude rings in the Healpix map with the given value of <code>nside</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; nside2nring(4)
15

julia&gt; nside2nring(256)
1023</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.nside2npix"><code>nside2npix</code></a>, <a href="#LibHealpix.npix2nside"><code>npix2nside</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L66-L86">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.ang2vec" href="#LibHealpix.ang2vec"><code>LibHealpix.ang2vec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ang2vec(theta, phi)</code></pre><p>Compute the Cartesian unit vector to the spherical coordinates <span>$(θ, ϕ)$</span>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>theta</code> - the inclination angle <span>$θ$</span></p></li><li><p><code>phi</code> - the azimuthal angle <span>$ϕ$</span></p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; ang2vec(0, 0)
3-element LibHealpix.UnitVector:
 0.0
 0.0
 1.0

julia&gt; ang2vec(π/2, π/2)
3-element LibHealpix.UnitVector:
 6.12323e-17
 1.0
 6.12323e-17</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.vec2ang"><code>vec2ang</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L133">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.vec2ang" href="#LibHealpix.vec2ang"><code>LibHealpix.vec2ang</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vec2ang(vec)</code></pre><p>Compute the spherical coordinates <span>$(θ, ϕ)$</span> from the given unit vector.</p><p><strong>Arguments:</strong></p><ul><li><p><code>vec</code> - the input Cartesian unit vector</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; vec2ang([1, 0, 0])
(1.5707963267948966, 0.0)

julia&gt; vec2ang([0, 1, 0])
(1.5707963267948966, 1.5707963267948966)

julia&gt; vec2ang([0, 0, 1])
(0.0, 0.0)</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.ang2vec"><code>ang2vec</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L170">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.nest2ring" href="#LibHealpix.nest2ring"><code>LibHealpix.nest2ring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nest2ring(nside, ipix)</code></pre><p>Convert the given pixel index from the nested to the ring indexing scheme.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ipix</code> - the pixel index (nested scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; nest2ring(256, 1)
391809

julia&gt; nest2ring(256, 2)
390785</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.ring2nest"><code>ring2nest</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L253-L274">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.ring2nest" href="#LibHealpix.ring2nest"><code>LibHealpix.ring2nest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ring2nest(nside, ipix)</code></pre><p>Convert the given pixel index from the ring to the nested indexing scheme.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ipix</code> - the pixel index (ring scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; ring2nest(256, 1)
65536

julia&gt; ring2nest(256, 2)
131072</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.nest2ring"><code>nest2ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L277-L298">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.ang2pix_nest" href="#LibHealpix.ang2pix_nest"><code>LibHealpix.ang2pix_nest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ang2pix_nest(nside, theta, phi)</code></pre><p>Compute the pixel index (in the nested scheme) that contains the point on the sphere given by the spherical coordinates <span>$(θ, ϕ)$</span>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>theta</code> - the inclination angle <span>$θ$</span></p></li><li><p><code>phi</code> - the azimuthal angle <span>$ϕ$</span></p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; ang2pix_nest(256, 0, 0)
65536

julia&gt; ang2pix_nest(256, π/2, π/2)
354987</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.ang2pix_ring"><code>ang2pix_ring</code></a>, <a href="#LibHealpix.pix2ang_nest"><code>pix2ang_nest</code></a>, <a href="#LibHealpix.pix2ang_ring"><code>pix2ang_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L301">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.ang2pix_ring" href="#LibHealpix.ang2pix_ring"><code>LibHealpix.ang2pix_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ang2pix_ring(nside, theta, phi)</code></pre><p>Compute the pixel index (in the ring scheme) that contains the point on the sphere given by the spherical coordinates <span>$(θ, ϕ)$</span>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>theta</code> - the inclination angle <span>$θ$</span></p></li><li><p><code>phi</code> - the azimuthal angle <span>$ϕ$</span></p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; ang2pix_ring(256, 0, 0)
1

julia&gt; ang2pix_ring(256, π/2, π/2)
392961</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.ang2pix_nest"><code>ang2pix_nest</code></a>, <a href="#LibHealpix.pix2ang_nest"><code>pix2ang_nest</code></a>, <a href="#LibHealpix.pix2ang_ring"><code>pix2ang_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L327">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.pix2ang_nest" href="#LibHealpix.pix2ang_nest"><code>LibHealpix.pix2ang_nest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pix2ang_nest(nside, ipix)</code></pre><p>Compute the spherical coordinates <span>$(θ, ϕ)$</span> corresponding to the given pixel center.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ipix</code> - the pixel index (nested scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; pix2ang_nest(256, 1)
(1.5681921571847817, 0.7853981633974483)

julia&gt; pix2ang_nest(256, 2)
(1.5655879699137618, 0.7884661249732196)</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.pix2ang_ring"><code>pix2ang_ring</code></a>, <a href="#LibHealpix.ang2pix_nest"><code>ang2pix_nest</code></a>, <a href="#LibHealpix.ang2pix_ring"><code>ang2pix_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L353">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.pix2ang_ring" href="#LibHealpix.pix2ang_ring"><code>LibHealpix.pix2ang_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pix2ang_ring(nside, ipix)</code></pre><p>Compute the spherical coordinates <span>$(θ, ϕ)$</span> corresponding to the given pixel center.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ipix</code> - the pixel index (ring scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; pix2ang_ring(256, 1)
(0.0031894411211228764, 0.7853981633974483)

julia&gt; pix2ang_ring(256, 2)
(0.0031894411211228764, 2.356194490192345)</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.pix2ang_nest"><code>pix2ang_nest</code></a>, <a href="#LibHealpix.ang2pix_nest"><code>ang2pix_nest</code></a>, <a href="#LibHealpix.ang2pix_ring"><code>ang2pix_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L377">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.vec2pix_nest" href="#LibHealpix.vec2pix_nest"><code>LibHealpix.vec2pix_nest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vec2pix_nest(nside, vec)</code></pre><p>Compute the pixel index (in the nested scheme) that contains the point on the sphere given by the Cartesian unit vector.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>vec</code> - the input Cartesian unit vector</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; vec2pix_nest(256, [1, 0, 0])
289451

julia&gt; vec2pix_nest(256, [0, 1, 0])
354987

julia&gt; vec2pix_nest(256, [0, 0, 1])
65536</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.vec2pix_ring"><code>vec2pix_ring</code></a>, <a href="#LibHealpix.pix2vec_nest"><code>pix2vec_nest</code></a>, <a href="#LibHealpix.pix2vec_ring"><code>pix2vec_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L401-L426">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.vec2pix_ring" href="#LibHealpix.vec2pix_ring"><code>LibHealpix.vec2pix_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vec2pix_ring(nside, vec)</code></pre><p>Compute the pixel index (in the ring scheme) that contains the point on the sphere given by the Cartesian unit vector.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>vec</code> - the input Cartesian unit vector</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; vec2pix_ring(256, [1, 0, 0])
392705

julia&gt; vec2pix_ring(256, [0, 1, 0])
392961

julia&gt; vec2pix_ring(256, [0, 0, 1])
1</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.vec2pix_nest"><code>vec2pix_nest</code></a>, <a href="#LibHealpix.pix2vec_nest"><code>pix2vec_nest</code></a>, <a href="#LibHealpix.pix2vec_ring"><code>pix2vec_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L429-L454">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.pix2vec_nest" href="#LibHealpix.pix2vec_nest"><code>LibHealpix.pix2vec_nest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pix2vec_nest(nside, ipix)</code></pre><p>Compute the Cartesian unit vector corresponding to the given pixel center.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ipix</code> - the pixel index (nested scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; pix2vec_nest(256, 1)
3-element LibHealpix.UnitVector:
 0.707104
 0.707104
 0.00260417

julia&gt; pix2vec_nest(256, 2)
3-element LibHealpix.UnitVector:
 0.704925
 0.709263
 0.00520833</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.pix2vec_ring"><code>pix2vec_ring</code></a>, <a href="#LibHealpix.vec2pix_nest"><code>vec2pix_nest</code></a>, <a href="#LibHealpix.vec2pix_ring"><code>vec2pix_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L457-L484">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.pix2vec_ring" href="#LibHealpix.pix2vec_ring"><code>LibHealpix.pix2vec_ring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pix2vec_ring(nside, ipix)</code></pre><p>Compute the Cartesian unit vector corresponding to the given pixel center.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ipix</code> - the pixel index (ring scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; pix2vec_ring(256, 1)
3-element LibHealpix.UnitVector:
 0.00225527
 0.00225527
 0.999995

julia&gt; pix2vec_ring(256, 2)
3-element LibHealpix.UnitVector:
 -0.00225527
  0.00225527
  0.999995</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.pix2vec_nest"><code>pix2vec_nest</code></a>, <a href="#LibHealpix.vec2pix_nest"><code>vec2pix_nest</code></a>, <a href="#LibHealpix.vec2pix_ring"><code>vec2pix_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/pixel.jl#L487-L514">source</a><br/></section><h2><a class="nav-anchor" id="Healpix-Maps-1" href="#Healpix-Maps-1">Healpix Maps</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.HealpixMap" href="#LibHealpix.HealpixMap"><code>LibHealpix.HealpixMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">abstract type HealpixMap{T&lt;:Number} &lt;: AbstractVector{T}</code></pre><p>This abstract type represents a Healpix equal-area pixelization of the sphere.</p><p><strong>Subtypes:</strong></p><ul><li><p><a href="#LibHealpix.RingHealpixMap"><code>RingHealpixMap</code></a> - a <code>HealpixMap</code> where pixels are ordered along rings of constant   latitude. This ordering should be used for performing spherical harmonic transforms.</p></li><li><p><a href="#LibHealpix.NestHealpixMap"><code>NestHealpixMap</code></a> - a <code>HealpixMap</code> where nearby pixels also tend to be nearby in memory.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L16-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.RingHealpixMap" href="#LibHealpix.RingHealpixMap"><code>LibHealpix.RingHealpixMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">struct RingHealpixMap{T&lt;:Number} &lt;: HealpixMap{T}</code></pre><p>This type represents a Healpix equal-area pixelization of the sphere where pixels are ordered along rings of constant latitude.</p><p><strong>Fields:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>pixels</code> - the list of pixel values</p></li></ul><p><strong>Constructors:</strong></p><pre><code class="language-none">RingHealpixMap(T, nside)</code></pre><p>Construct a <code>RingHealpixMap</code> with the element type <code>T</code> and resolution parameter <code>nside</code>. All of the pixels will be set to zero initially.</p><pre><code class="language-none">RingHealpixMap(pixels)</code></pre><p>Construct a <code>RingHealpixMap</code> with the given list of pixel values. The resolution parameter <code>nside</code> will be inferred from the number of pixels. However a <code>LibHealpixException</code> will be thrown if given an invalid number of pixels.</p><pre><code class="language-none">RingHealpixMap(nside, pixels)</code></pre><p>Construct a <code>RingHealpixMap</code> with the given resolution parameter <code>nside</code> and initial list of pixel values. This constructor is cheaper than <code>RingHealpixMap(pixels)</code> if the correct value of <code>nside</code> is already known.</p><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; map = RingHealpixMap(Float64, 256)
       for idx = 1:length(map)
           map[idx] = randn()
       end
       map + map == 2map
true</code></pre><p><strong>See also:</strong> <a href="#LibHealpix.HealpixMap"><code>HealpixMap</code></a>, <a href="#LibHealpix.NestHealpixMap"><code>NestHealpixMap</code></a>, <a href="#LibHealpix.Alm"><code>Alm</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L55-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.NestHealpixMap" href="#LibHealpix.NestHealpixMap"><code>LibHealpix.NestHealpixMap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">struct NestHealpixMap{T&lt;:Number} &lt;: HealpixMap{T}</code></pre><p>This type represents a Healpix equal-area pixelization of the sphere where nearby pixels also tend to be nearby in memory.</p><p><strong>Fields:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>pixels</code> - the list of pixel values</p></li></ul><p><strong>Constructors:</strong></p><pre><code class="language-none">NestHealpixMap(T, nside)</code></pre><p>Construct a <code>NestHealpixMap</code> with the element type <code>T</code> and resolution parameter <code>nside</code>. All of the pixels will be set to zero initially.</p><pre><code class="language-none">NestHealpixMap(pixels)</code></pre><p>Construct a <code>NestHealpixMap</code> with the given list of pixel values. The resolution parameter <code>nside</code> will be inferred from the number of pixels. However a <code>LibHealpixException</code> will be thrown if given an invalid number of pixels.</p><pre><code class="language-none">NestHealpixMap(nside, pixels)</code></pre><p>Construct a <code>NestHealpixMap</code> with the given resolution parameter <code>nside</code> and initial list of pixel values. This constructor is cheaper than <code>NestHealpixMap(pixels)</code> if the correct value of <code>nside</code> is already known.</p><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; map = NestHealpixMap(Float64, 256)
       for idx = 1:length(map)
           map[idx] = randn()
       end
       map + map == 2map
true</code></pre><p><strong>See also:</strong> <a href="#LibHealpix.HealpixMap"><code>HealpixMap</code></a>, <a href="#LibHealpix.RingHealpixMap"><code>RingHealpixMap</code></a>, <a href="#LibHealpix.Alm"><code>Alm</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L100-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.writehealpix" href="#LibHealpix.writehealpix"><code>LibHealpix.writehealpix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writehealpix(filename, map)</code></pre><p>Write the <code>HealpixMap</code> to disk as a FITS image.</p><p><strong>Arguments:</strong></p><ul><li><p><code>filename</code> - the name of the output file (eg. <code>&quot;/path/to/healpix.fits&quot;</code>)</p></li><li><p><code>map</code> - the Healpix map to write</p></li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><p><code>coordsys</code> - the coordinate system of the map (one of <code>&quot;G&quot;</code> galactic, <code>&quot;E&quot;</code> ecliptic, or <code>&quot;C&quot;</code>   celestial)</p></li><li><p><code>replace</code> - if set to true, the output file will be automatically overwritten if it exists</p></li></ul><p><strong>See also:</strong> <a href="#LibHealpix.readhealpix"><code>readhealpix</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/io.jl#L16-L33">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.readhealpix" href="#LibHealpix.readhealpix"><code>LibHealpix.readhealpix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readhealpix(filename)</code></pre><p>Read a <code>HealpixMap</code> (stored as a FITS image) from disk.</p><p><strong>Arguments:</strong></p><ul><li><p><code>filename</code> - the name of the input file (eg. <code>&quot;/path/to/healpix.fits&quot;</code>)</p></li></ul><p><strong>See also:</strong> <a href="#LibHealpix.writehealpix"><code>writehealpix</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/io.jl#L71-L81">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.ang2pix" href="#LibHealpix.ang2pix"><code>LibHealpix.ang2pix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ang2pix(map, theta, phi)</code></pre><p>Compute the pixel index that contains the point on the sphere given by the spherical coordinates <span>$(θ, ϕ)$</span>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map</p></li><li><p><code>theta</code> - the inclination angle <span>$θ$</span> (in radians)</p></li><li><p><code>phi</code> - the azimuthal angle <span>$ϕ$</span> (in radians)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; ang2pix(RingHealpixMap(Float64, 256), π/2, π/2)
392961

julia&gt; ang2pix(NestHealpixMap(Float64, 256), π/2, π/2)
354987</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.pix2ang"><code>pix2ang</code></a>, <a href="#LibHealpix.ang2pix_nest"><code>ang2pix_nest</code></a>, <a href="#LibHealpix.ang2pix_ring"><code>ang2pix_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L189">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.pix2ang" href="#LibHealpix.pix2ang"><code>LibHealpix.pix2ang</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pix2ang(map, ipix)</code></pre><p>Compute the spherical coordinates <span>$(θ, ϕ)$</span> corresponding to the given pixel center.</p><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map</p></li><li><p><code>ipix</code> - the pixel index</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; pix2ang(RingHealpixMap(Float64, 256), 1)
(0.0031894411211228764, 0.7853981633974483)

julia&gt; pix2ang(NestHealpixMap(Float64, 256), 1)
(1.5681921571847817, 0.7853981633974483)</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.ang2pix"><code>ang2pix</code></a>, <a href="#LibHealpix.pix2ang_nest"><code>pix2ang_nest</code></a>, <a href="#LibHealpix.pix2ang_ring"><code>pix2ang_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L215">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.vec2pix" href="#LibHealpix.vec2pix"><code>LibHealpix.vec2pix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vec2pix(map, vec)</code></pre><p>Compute the pixel index that contains the point on the sphere given by the Cartesian unit vector.</p><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map</p></li><li><p><code>vec</code> - the input Cartesian unit vector</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; vec2pix(RingHealpixMap(Float64, 256), [0, 0, 1])
1

julia&gt; vec2pix(NestHealpixMap(Float64, 256), [0, 0, 1])
65536</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.pix2vec"><code>pix2vec</code></a>, <a href="#LibHealpix.vec2pix_nest"><code>vec2pix_nest</code></a>, <a href="#LibHealpix.vec2pix_ring"><code>vec2pix_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L239-L260">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.pix2vec" href="#LibHealpix.pix2vec"><code>LibHealpix.pix2vec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pix2vec(map, ipix)</code></pre><p>Compute the Cartesian unit vector corresponding to the given pixel center.</p><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map</p></li><li><p><code>ipix</code> - the pixel index (nested scheme)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; pix2vec(RingHealpixMap(Float64, 256), 1)
3-element LibHealpix.UnitVector:
 0.00225527
 0.00225527
 0.999995

julia&gt; pix2vec(NestHealpixMap(Float64, 256), 1)
3-element LibHealpix.UnitVector:
 0.707104
 0.707104
 0.00260417</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.vec2pix"><code>vec2pix</code></a>, <a href="#LibHealpix.pix2vec_nest"><code>pix2vec_nest</code></a>, <a href="#LibHealpix.pix2vec_ring"><code>pix2vec_ring</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L263-L290">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.interpolate" href="#LibHealpix.interpolate"><code>LibHealpix.interpolate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LibHealpix.interpolate(map, theta, phi)</code></pre><p>Linearly interpolate the Healpix map at the given spherical coordinates <span>$(θ, ϕ)$</span>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map</p></li><li><p><code>theta</code> - the inclination angle <span>$θ$</span> (in radians)</p></li><li><p><code>phi</code> - the azimuthal angle <span>$ϕ$</span> (in radians)</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; healpixmap = RingHealpixMap(Float64, 256)
       for idx = 1:length(healpixmap)
           healpixmap[idx] = idx
       end
       LibHealpix.interpolate(healpixmap, 0, 0)
2.5</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.ang2pix"><code>ang2pix</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L377">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.query_disc" href="#LibHealpix.query_disc"><code>LibHealpix.query_disc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">query_disc(nside, ordering, theta, phi, radius; inclusive=true)
query_disc(map, theta, phi, radius; inclusive=true)</code></pre><p>Return a list of all pixels contained within a circular disc of the given radius.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nside</code> - the Healpix resolution parameter</p></li><li><p><code>ordering</code> - the ordering of the Healpix map (either <code>LibHealpix.ring</code> or <code>LibHealpix.nest</code></p></li><li><p><code>theta</code> - the inclination angle <span>$θ$</span> (in radians)</p></li><li><p><code>phi</code> - the azimuthal angle <span>$ϕ$</span> (in radians)</p></li><li><p><code>radius</code> - the radius of the disc (in radians)</p></li><li><p><code>map</code> - the input Healpix map (<code>nside</code> and <code>ordering</code> will be inferred from the map)</p></li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><p><code>inclusive</code> - if set to `true pixels partially contained within the disc will be included,   otherwise they are excluded</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; query_disc(512, LibHealpix.ring, 0, 0, deg2rad(10/60), inclusive=false)
4-element Array{Int32,1}:
 1
 2
 3
 4

julia&gt; query_disc(512, LibHealpix.ring, 0, 0, deg2rad(10/60), inclusive=true) |&gt; length
24</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/map.jl#L474">source</a><br/></section><h2><a class="nav-anchor" id="Spherical-Harmonic-Coefficients-1" href="#Spherical-Harmonic-Coefficients-1">Spherical Harmonic Coefficients</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.Alm" href="#LibHealpix.Alm"><code>LibHealpix.Alm</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">struct Alm{T&lt;:Number} &lt;: AbstractVector{T}</code></pre><p>This type holds a vector of spherical harmonic coefficients.</p><p><strong>Fields:</strong></p><ul><li><p><code>lmax</code> - the maximum value for the <span>$l$</span> quantum number</p></li><li><p><code>mmax</code> - the maximum value for the <span>$m$</span> quantum number (note that <span>$m ≤ l$</span>)</p></li><li><p><code>coefficients</code> - the list of spherical harmonic coefficients</p></li></ul><p><strong>Constructors:</strong></p><pre><code class="language-none">Alm(T, lmax, mmax)</code></pre><p>Construct an <code>Alm</code> object that will store all spherical harmonic coefficients with element type <code>T</code>, <span>$l ≤ lₘₐₓ$</span>, and <span>$m ≤ mₘₐₓ$</span>. All of the coefficients will be initialized to zero.</p><pre><code class="language-none">Alm(lmax, mmax, coefficients)</code></pre><p>Construct an <code>Alm</code> object with the given list of initial coefficients corresponding to <span>$l ≤ lₘₐₓ$</span>, and <span>$m ≤ mₘₐₓ$</span>. A <code>LibHealpixException</code> will be thrown if too many or too few coefficients are provided.</p><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; alm = Alm(Complex128, 10, 10)
       for (l, m) in lm(alm)
           @lm alm[l, m] = l * m
       end
       @lm(alm[10, 5]) == 50
true</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>lm</code> function is used to iterate over the spherical harmonic quantum numbers <span>$l$</span> and <span>$m$</span>.</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>@lm</code> macro is used to index into an <code>Alm</code> object when given the spherical harmonic quantum numbers <span>$l$</span> and <span>$m$</span>.</p></div></div><p><strong>See also:</strong> <a href="#LibHealpix.RingHealpixMap"><code>RingHealpixMap</code></a>, <a href="#LibHealpix.NestHealpixMap"><code>NestHealpixMap</code></a>, <a href="#LibHealpix.lm"><code>lm</code></a>, <a href="#LibHealpix.@lm"><code>@lm</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/alm.jl#L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.lm" href="#LibHealpix.lm"><code>LibHealpix.lm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lm(lmax, mmax)
lm(alm)</code></pre><p>Construct an interator for iterating over all possible values of the spherical harmonic quantum numbers <span>$l ≤ lₘₐₓ$</span> and <span>$m ≤ mₘₐₓ$</span>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>lmax</code> - the maximum value of <span>$l$</span></p></li><li><p><code>mmax</code> - the maximum value of <span>$m$</span></p></li><li><p><code>alm</code> - if an <code>Alm</code> object is provided, <code>lmax</code> and <code>mmax</code> will be inferred from the corresponding   fields</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; for (l, m) in lm(2, 1)
           @show l, m
       end
(l, m) = (0, 0)
(l, m) = (1, 0)
(l, m) = (2, 0)
(l, m) = (1, 1)
(l, m) = (2, 1)</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.Alm"><code>Alm</code></a>, <a href="#LibHealpix.@lm"><code>@lm</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/alm.jl#L247">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.@lm" href="#LibHealpix.@lm"><code>LibHealpix.@lm</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@lm</code></pre><p>This macro is used to index an <code>Alm</code> object when given the values for quantum numbers <span>$l$</span> and <span>$m$</span>.</p><p><strong>Usage</strong></p><pre><code class="language-julia-repl">julia&gt; alm = Alm(Int, 2, 1)
       for (l, m) in lm(alm)
           @lm alm[l, m] = l + m
       end

julia&gt; @lm alm[1, 1]
2

julia&gt; @lm alm[1, :] # all coefficients with l == 1
2-element Array{Int64,1}:
 1
 2

julia&gt; @lm alm[:, 1] # all coefficients with m == 1
2-element Array{Int64,1}:
 2
 3</code></pre><p><strong>Background</strong></p><p><code>Alm</code> implements the <code>AbstractVector</code> interface which allows the type to be used in place of a standard <code>Vector</code> in many cases. This generally makes sense because <code>Alm</code> is simply a wrapper around a standard <code>Vector</code>.</p><p>However, one consequence of being an <code>AbstractVector</code> is that the two-element <code>getindex</code> function already has a meaning and therefore <code>alm[l, m]</code> <em>cannot</em> be used to mean &quot;give me the coefficient corresponding to the quantum numbers <span>$l$</span> and <span>$m$</span>&quot;. Instead <code>@lm alm[l, m]</code> calls a separate function that does give you the coefficient for <span>$l$</span> and <span>$m$</span>.</p><p><strong>See Also:</strong> <a href="#LibHealpix.Alm"><code>Alm</code></a>, <a href="#LibHealpix.lm"><code>lm</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/alm.jl#L155">source</a><br/></section><h2><a class="nav-anchor" id="Spherical-Harmonic-Transforms-1" href="#Spherical-Harmonic-Transforms-1">Spherical Harmonic Transforms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.map2alm" href="#LibHealpix.map2alm"><code>LibHealpix.map2alm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">map2alm(map, lmax, mmax)</code></pre><p>Compute the spherical harmonic coefficients of the given Healpix map by means of a spherical harmonic transform.</p><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map (must be ring ordered)</p></li><li><p><code>lmax</code> - the maximum value for the <span>$l$</span> quantum number</p></li><li><p><code>mmax</code> - the maximum value for the <span>$m$</span> quantum number</p></li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><p><code>iterations</code> - the number of iterations to perform</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Set <code>iterations</code> to something greater than 0 if more precision is required.</p></div></div><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; map = RingHealpixMap(Float64, 4)
       map[:] = 1
       alm = map2alm(map, 1, 1)
       @lm alm[0, 0]
3.5449077018110318 + 0.0im</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.alm2map"><code>alm2map</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/transforms.jl#L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.alm2map" href="#LibHealpix.alm2map"><code>LibHealpix.alm2map</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">alm2map(alm, nside)</code></pre><p>Compute the Healpix map corresponding to the given spherical harmonic coefficients by means of an inverse spherical harmonic transform.</p><p><strong>Arguments:</strong></p><ul><li><p><code>alm</code> - the input list of spherical harmonic coefficients</p></li><li><p><code>nside</code> - the resolution of the output Healpix map</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; alm = Alm(Complex128, 1, 1)
       @lm alm[0, 0] = 1
       map = alm2map(alm, 1)
12-element LibHealpix.RingHealpixMap{Float64}:
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095
 0.282095</code></pre><p><strong>See Also:</strong> <a href="#LibHealpix.map2alm"><code>map2alm</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/transforms.jl#L70-L103">source</a><br/></section><h2><a class="nav-anchor" id="Visualization-1" href="#Visualization-1">Visualization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LibHealpix.mollweide" href="#LibHealpix.mollweide"><code>LibHealpix.mollweide</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mollweide(map, size=(512, 1024))</code></pre><p>Create a Mollweide projected image of the given Healpix map.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The image values will be set to zero outside of the projection area.</p></div></div><p><strong>Arguments:</strong></p><ul><li><p><code>map</code> - the input Healpix map</p></li><li><p><code>size</code> - the size of the output image</p></li></ul><p><strong>Usage:</strong></p><pre><code class="language-julia-repl">julia&gt; map = RingHealpixMap(Int, 1)
       map[:] = 1
       mollweide(map, (10, 20))
10×20 Array{Int64,2}:
 0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0  0  0
 0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0
 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0
 0  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0  0  0
 0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  0  0  0  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mweastwood/LibHealpix.jl/tree/5a16b17599b9373c57dd950e9e6d8f7b77a851b9/src/projections.jl#L16-L47">source</a><br/></section><footer><hr/><a class="previous" href="../cookbook/"><span class="direction">Previous</span><span class="title">Cookbook</span></a></footer></article></body></html>
